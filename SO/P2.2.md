
# Practica 2.2: Sistema de Ficheros

# Objetivos
En esta práctica se revisan las funciones del sistema básicas para manejar un sistema de ficheros, referentes a la creación de ficheros y directorios, duplicación de descriptores, obtención de información de ficheros o el uso de cerrojos.

# Creación y atributos de ficheros
El i-nodo de un fichero guarda diferentes atributos de éste, como por ejemplo el propietario, permisos de acceso, tamaño o los tiempos de acceso, modificación y creación. En esta sección veremos las llamadas al sistema más importantes para consultar y fijar estos atributos así como las herramientas del sistema para su gestión.

### Ejercicio 1

La herramienta principal para consultar el contenido y atributos básicos de un fichero es ls. Consultar la página de manual y estudiar el uso de las opciones -a -l -d -h -i -R -1 -F y --color. Estudiar el significado de la salida en cada caso.

### Ejercicio 2 
El  _modo_  de un fichero es <tipo><rwx_propietario><rwx_grupo><rwx_resto>:

- tipo: - fichero ordinario; d directorio; l enlace; c dispositivo carácter; b dispositivo bloque; p FIFO; s socket

- rwx: r lectura (4); w escritura (2); x ejecución (1)

Comprobar los permisos de algunos directorios (con ls -ld).

### Ejercicio 3

Los permisos se pueden otorgar de forma selectiva usando la notación octal o la simbólica. Ejemplo, probar las siguientes órdenes (equivalentes):

- chmod 540 fichero

- chmod u+rx,g+r-wx,o-wxr fichero

¿Cómo se podrían fijar los permisos rw-r--r-x, de las dos formas?


### Ejercicio 4
Crear un directorio y quitar los permisos de ejecución para usuario, grupo y otros. Intentar cambiar al directorio.

### Ejercicio 5
Escribir un programa que, usando la llamada open(2), cree un fichero con los permisos rw-r--r-x. Comprobar el resultado y las características del fichero con la orden ls.

### Ejercicio 6
Cuando se crea un fichero, los permisos por defecto se derivan de la máscara de usuario (_umask_). El comando interno de la  _shell_ umask permite consultar y fijar esta máscara. Usando este comando, fijar la máscara de forma que los nuevos ficheros no tengan permiso de escritura para el grupo y ningún permiso para otros. Comprobar el funcionamiento con los comandos touch, mkdir y ls.

### Ejercicio 7
Modificar el ejercicio 5 para que, antes de crear el fichero, se fije la máscara igual que en el ejercicio 6. Comprobar el resultado con el comando ls. Comprobar que la máscara del proceso padre (la  _shell_) no cambia.
### Ejercicio 8
El comando ls puede mostrar el i-nodo con la opción -i. El resto de información del i-nodo puede obtenerse usando el comando stat. Consultar las opciones del comando y comprobar su funcionamiento.

### Ejercicio 9
Escribir un programa que emule el comportamiento del comando stat y muestre:

- El número  _major_  y  _minor_ asociado al dispositivo.

- El número de i-nodo del fichero.

- El tipo de fichero (directorio, enlace simbólico o fichero ordinario).

- La hora en la que se accedió el fichero por última vez. ¿Qué diferencia hay entre st_mtime y st_ctime?

### Ejercicio 10
Los enlaces se crean con la orden ln:

- La opción -s crea un enlace simbólico. Crear un enlace simbólico a un fichero ordinario y otro a un directorio. Comprobar el resultado con ls -l y ls -i. Determinar el i-nodo de cada fichero.

- Repetir el apartado anterior con enlaces rígidos. Determinar los i-nodos de los ficheros y las propiedades con stat (observar el atributo número de enlaces).

- ¿Qué sucede cuando se borra uno de los enlaces rígidos? ¿Qué sucede si se borra uno de los enlaces simbólicos? ¿Y si se borra el fichero original?

# Información horaria del sistema

### Ejercicio 11

Las llamadas link(2) y symlink(2) crean enlaces rígidos y simbólicos, respectivamente. Escribir un programa que reciba una ruta a un fichero como argumento. Si la ruta es un fichero regular, creará un enlace simbólico y rígido con el mismo nombre terminado en .sym y .hard, respectivamente. Comprobar el resultado con la orden ls.

# Redirecciones y duplicación de descriptores

### Ejercicio 12
Escribir un programa que muestre la hora, en segundos desde el Epoch, usando la función *time(2)*.

### Ejercicio 13 
Escribir un programa que mida, en microsegundos usando la función *gettimeofday(2)*, lo que tarda un bucle que incrementa una variable un millón de veces.
### Ejercicio 14
Escribir un programa que muestre el año usando la función *localtime(3)*.
### Ejercicio 15
Modificar el programa anterior para que imprima la hora de forma legible, como "lunes, 29 de octubre de 2018, 10:34", usando la función *strftime(3)*.

**Nota:**  Para establecer la configuración regional (_locale_, como idioma o formato de hora) en el programa según la configuración actual, usar la función *setlocale(3)*, por ejemplo, *setlocale(LC_ALL, "")*. Para cambiar la configuración regional, ejecutar, por ejemplo, export LC_ALL="es_ES", o bien, export LC_TIME="es_ES".**_Nota:_**  Para establecer la configuración regional (_locale_, como idioma o formato de hora) en el programa según la configuración actual, usar la función setlocale(3), por ejemplo, setlocale(LC_ALL, ""). Para cambiar la configuración regional, ejecutar, por ejemplo, export LC_ALL="es_ES", o bien, export LC_TIME="es_ES".
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5NTIzMjY1NDBdfQ==
-->