
# Practica 2.3: Procesos

# Objetivos
En esta práctica se revisan las funciones del sistema básicas para la gestión de procesos: políticas de planificación, creación de procesos, grupos de procesos, sesiones, recursos de un proceso y gestión de señales.

# Políticas de planificación
En esta sección estudiaremos los parámetros de planificador de Linux que permiten variar y consultar la prioridad de un proceso. Veremos tanto la interfaz del sistema como algunos comandos importantes.

### Ejercicio 1

La política de planificación y la prioridad de un proceso puede consultarse y modificarse con el comando chrt. Adicionalmente, los comandos nice y renice permiten ajustar el valor de  _nice_  de un proceso. Consultar la página de manual de ambos comandos y comprobar su funcionamiento cambiando el valor de  _nice_  de la  _shell_  a -10 y después cambiando su política de planificación a SCHED_FIFO con prioridad 12.

### Ejercicio 2 

Escribir un programa que muestre la política de planificación (como cadena) y la prioridad del proceso actual, además de mostrar los valores máximo y mínimo de la prioridad para la política de planificación.

### Ejercicio 3


Ejecutar el programa anterior en una  _shell_  con prioridad 12 y política de planificación SCHED_FIFO como la del ejercicio 1. ¿Cuál es la prioridad en este caso del programa? ¿Se heredan los atributos de planificación?

# Grupos de procesos y sesiones
### Ejercicio 4
Crear un directorio y quitar los permisos de ejecución para usuario, grupo y otros. Intentar cambiar al directorio.

### Ejercicio 5
Escribir un programa que, usando la llamada open(2), cree un fichero con los permisos rw-r--r-x. Comprobar el resultado y las características del fichero con la orden ls.

### Ejercicio 6
Cuando se crea un fichero, los permisos por defecto se derivan de la máscara de usuario (_umask_). El comando interno de la  _shell_ umask permite consultar y fijar esta máscara. Usando este comando, fijar la máscara de forma que los nuevos ficheros no tengan permiso de escritura para el grupo y ningún permiso para otros. Comprobar el funcionamiento con los comandos touch, mkdir y ls.

# Ejecución de programas

### Ejercicio 7
Modificar el ejercicio 5 para que, antes de crear el fichero, se fije la máscara igual que en el ejercicio 6. Comprobar el resultado con el comando ls. Comprobar que la máscara del proceso padre (la  _shell_) no cambia.
### Ejercicio 8
El comando ls puede mostrar el i-nodo con la opción -i. El resto de información del i-nodo puede obtenerse usando el comando stat. Consultar las opciones del comando y comprobar su funcionamiento.

# Señales

### Ejercicio 9
Escribir un programa que emule el comportamiento del comando stat y muestre:

- El número  _major_  y  _minor_ asociado al dispositivo.

- El número de i-nodo del fichero.

- El tipo de fichero (directorio, enlace simbólico o fichero ordinario).

- La hora en la que se accedió el fichero por última vez. ¿Qué diferencia hay entre st_mtime y st_ctime?

### Ejercicio 10
Los enlaces se crean con la orden ln:

- La opción -s crea un enlace simbólico. Crear un enlace simbólico a un fichero ordinario y otro a un directorio. Comprobar el resultado con ls -l y ls -i. Determinar el i-nodo de cada fichero.

- Repetir el apartado anterior con enlaces rígidos. Determinar los i-nodos de los ficheros y las propiedades con stat (observar el atributo número de enlaces).

- ¿Qué sucede cuando se borra uno de los enlaces rígidos? ¿Qué sucede si se borra uno de los enlaces simbólicos? ¿Y si se borra el fichero original?

### Ejercicio 11

Las llamadas link(2) y symlink(2) crean enlaces rígidos y simbólicos, respectivamente. Escribir un programa que reciba una ruta a un fichero como argumento. Si la ruta es un fichero regular, creará un enlace simbólico y rígido con el mismo nombre terminado en .sym y .hard, respectivamente. Comprobar el resultado con la orden ls.


La  _shell_  proporciona operadores (>, >&, >>) que permiten redirigir un fichero a otro, ver los ejercicios propuestos en la práctica opcional. Esta funcionalidad se implementa mediante las llamadas dup(2) y dup2(2).

### Ejercicio 12
Escribir un programa que muestre la hora, en segundos desde el Epoch, usando la función *time(2)*.

### Ejercicio 13 
Modificar el programa anterior para que además de escribir en el fichero la salida estándar también se escriba la salida estándar de error. Comprobar el funcionamiento incluyendo varias sentencias que impriman en ambos flujos. ¿Hay alguna diferencia si las redirecciones se hacen en diferente orden? ¿Por qué no es lo mismo “ls > dirlist 2>&1” que “ls 2>&1 > dirlist”?

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgwMjA1MDg2Ml19
-->